<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何在博客文章中嵌入音乐</title>
    <link href="/2019/12/30/%E7%BD%91%E9%A1%B5%E5%B5%8C%E5%85%A5%E9%9F%B3%E4%B9%90/"/>
    <url>/2019/12/30/%E7%BD%91%E9%A1%B5%E5%B5%8C%E5%85%A5%E9%9F%B3%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<p>阅读一篇文章时，文字修辞手法不够烘托出感情色彩时，你需要一点音乐来帮助你，这篇文章记录着我的小情调</p><a id="more"></a><h2 id="Markdown-一门很神奇的语言"><a href="#Markdown-一门很神奇的语言" class="headerlink" title="Markdown 一门很神奇的语言"></a>Markdown 一门很神奇的语言</h2><p>在md文件中嵌入html标签可以达到嵌入音乐的目的，为啥是md文件而不是html文件呢？因为博客文章大部分都是用md编写然后通过框架转成html结构，其实markdown算是html的兄弟，都是标记语言</p><p><strong>注意 ：本篇文章所用音乐及其来源切勿作于商业用途，仅供学习和参考</strong></p><h3 id="audio-标签"><a href="#audio-标签" class="headerlink" title="audio 标签"></a>audio 标签</h3><pre><code class="html">&lt;audio controls=&quot;controls&quot; autoplay=&quot;autoplay&quot;&gt;  &lt;source src=&quot;音乐资源路径&quot; type=&quot;audio/mp3&quot; /&gt;&lt;/audio&gt;</code></pre><audio controls="controls">  <source src="http://m8.music.126.net/20191230155935/e94c9276e1546d89729d7ee6f5adb390/ymusic/0459/045c/520c/330c359473365e50a368ef0d43bc612f.mp3" type="audio/mp3" /></audio><p>audio属于html 5的元素，在html 4中不支持，但对于大部分浏览器而言还是支持的 </p><h3 id="网易云音乐生成外部链接"><a href="#网易云音乐生成外部链接" class="headerlink" title="网易云音乐生成外部链接"></a>网易云音乐生成外部链接</h3><p>缺点现在很明显就是很多好听喜欢的歌曲不能分享生成外部链接了(由于版权保护，暂不支持分享🤣)，如何生成外部链接🤔，请自行百度or谷歌，其实就是打开网页版的网易云音乐，很快就能找到了</p><pre><code class="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;生成的链接&quot;&gt;&lt;/iframe&gt;</code></pre><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=542541179&auto=1&height=66"></iframe>仔细查看资源链接会发现后面有type,id,auto等字段，id是歌曲编码，auto是自动播放，自动播放在chrome上好像不生效，手机浏览器上可生效，还可以生成歌单外链也可以使用，只不过我没有看到就不做多的演示了，点到为止<h3 id="embed-标签"><a href="#embed-标签" class="headerlink" title="embed 标签"></a>embed 标签</h3><p>这两个都是引用外部内容的容器，什么地图，音频，视频都是外部内容，使用的时候兼容性不佳，可能会出现空白或者无法播放情况</p><pre><code class="html">&lt;embed height=&quot;100&quot; width=&quot;100&quot; src=&quot;音乐资源路径&quot; /&gt;</code></pre><p><embed        height="100"        width="50%"       src="http://m7.music.126.net/20191230162141/bf97b91a65916183c8e300e2ecf0b879/ymusic/5608/0e09/0f53/abf0f817349caa55389a890edfffa21e.mp3" /></p><p>⚡警告⚡ ⚡警告⚡ ⚡警告⚡</p><p>最后推荐一个最佳适配方案，audio 和 embed结合使用，提高兼容性</p><pre><code class="html">&lt;audio controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; height=&quot;100&quot; width=&quot;100&quot;&gt;  &lt;source src=&quot;音乐资源路径&quot; type=&quot;audio/mp3&quot; /&gt;    &lt;embed height=&quot;100&quot; width=&quot;100&quot; src=&quot;音乐资源路径&quot; /&gt;&lt;/audio&gt;</code></pre><audio controls="controls" autoplay="autoplay" height="100" width="100">  <source src="http://m7.music.126.net/20191230171949/ddc6b1674664bf31bdd4851dd58a5372/ymusic/0058/050b/050c/722ab2fd3f2af0a151ad2f2840959bc8.mp3" type="audio/mp3" />      <embed height="100" width="100" src="https://m7.music.126.net/20191230162141/bf97b91a65916183c8e300e2ecf0b879/ymusic/5608/0e09/0f53/abf0f817349caa55389a890edfffa21e.mp3" /></audio><p>好了，赶紧打开笔记本电脑动手试试吧📏</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小技能</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学会看懂UML图</title>
    <link href="/2018/01/12/UML%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9B%BE%E5%8F%8A%E7%B1%BB%E5%9B%BE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2018/01/12/UML%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9B%BE%E5%8F%8A%E7%B1%BB%E5%9B%BE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="统一建模语言简介"><a href="#统一建模语言简介" class="headerlink" title="统一建模语言简介"></a>统一建模语言简介</h2><p>​        统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。<br>统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。</p><p>​        主要介绍软件中经常用到的类图，以及类之间的关系。另外，在实验部分将简单介绍 UML 建模工具的使用方法，当前业界使用最广泛的是 Rational Rose。使用 Umlet 的人也很多，它是一个轻量级的开源 UML 建模工具，简单实用，常用于小型软件系统的开发与设计。</p><h4 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h4><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。<br>(1) 类名（Name）是一个字符串，例如，Student。</p><pre><code>[可见性]属性名:类型[=默认值]</code></pre><p>例如：-name:String<br>注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。</p><pre><code>[可见性]名称(参数列表)[:返回类型]</code></pre><p>例如：+display():void。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121K933555.gif" srcset="/img/loading.gif" alt="Student 类"></p><p>​                                                                        图 1 所示是学生类的 UML 表示。</p><h4 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h4><p>接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121K9493J.gif" srcset="/img/loading.gif" alt="Graph 接口"></p><p>​                                                                    图 2 所示是图形类接口的 UMDL 表示。</p><h4 id="3-类图"><a href="#3-类图" class="headerlink" title="3. 类图"></a>3. 类图</h4><p>类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。<br>类图中的类可以通过某种编程 语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。图 3 所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。</p><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121P6195T.gif" srcset="/img/loading.gif" alt="计算长方形和圆形的周长与面积”的类图"></p><p>​                                                            图3 “计算长方形和圆形的周长与面积”的类图</p><h4 id="1-依赖关系"><a href="#1-依赖关系" class="headerlink" title="1. 依赖关系"></a>1. 依赖关系</h4><p>依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。<br>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。图 4 所示是人与手机的关系图，人通过手机的语音传送方法打电话。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121PA2Y5.gif" srcset="/img/loading.gif" alt="依赖关系的实例"></p><p>​                                                                                    图4 依赖关系的实例</p><h4 id="2-关联关系"><a href="#2-关联关系" class="headerlink" title="2. 关联关系"></a>2. 关联关系</h4><p>关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。<br>关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p><p>​                                <img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121Q5115Q.gif" srcset="/img/loading.gif" alt="关联关系的实例"><br>​                                                                                    图5 关联关系的实例</p><h4 id="3-聚合关系"><a href="#3-聚合关系" class="headerlink" title="3. 聚合关系"></a>3. 聚合关系</h4><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。<br>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>​                                    <img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121Q541410.gif" srcset="/img/loading.gif" alt="聚合关系的实例"><br>​                                                                                        图6 聚合关系的实例</p><h4 id="4-组合关系"><a href="#4-组合关系" class="headerlink" title="4.组合关系"></a>4.组合关系</h4><p>组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。<br>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>​                                    <img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121QFD27.gif" srcset="/img/loading.gif" alt="组合关系的实例"><br>​                                                                                            图7 组合关系的实例</p><h4 id="5-泛化关系"><a href="#5-泛化关系" class="headerlink" title="5.泛化关系"></a>5.泛化关系</h4><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。<br>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如图 8 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121Q62C57.gif" srcset="/img/loading.gif" alt="泛化关系的实例"></p><p>​                                                                                    图8 泛化关系的实例</p><h4 id="6-实现关系"><a href="#6-实现关系" class="headerlink" title="6.实现关系"></a>6.实现关系</h4><p>实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。<br>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181112/3-1Q1121QI4317.gif" srcset="/img/loading.gif" alt="实现关系的实例"></p><p>​                                                                                图9 实现关系的实例</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内功</tag>
      
      <tag>概念文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的分类</title>
    <link href="/2018/01/12/%E5%88%9B%E5%BB%BA%E5%9E%8B%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2018/01/12/%E5%88%9B%E5%BB%BA%E5%9E%8B%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>​        创建型模式的主要关注点是“怎样创建对象？”，它这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。</p><ol><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li><strong>工厂方法（FactoryMethod）模式</strong>：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li></ol><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>​        结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式</p><ol><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li><strong>适配器（Adapter）模式</strong>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li></ol><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>​        行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。<br>​        行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型。</p><p>模式行为型模式是 GoF 中最为庞大的一类，它包含以下 11 种模式。</p><ol><li><strong>模板方法（Template Method）模式</strong>：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li><strong>解释器（Interpreter）模式</strong>：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内功</tag>
      
      <tag>概念文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/2018/01/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2018/01/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="oop设计原则"><a href="#oop设计原则" class="headerlink" title="oop设计原则"></a>oop设计原则</h1><p>​        在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>​        开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。<br>这里的软件实体包括以下几个部分：<br>​        开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>下面以 Windows 的桌面主题为例介绍开闭原则的应用。</p><p>分析：Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的，其类图如图 1 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q113100151L5.gif" srcset="/img/loading.gif" alt="Windows的桌面主题类图"></p><p>​                                                                            图1 Windows的桌面主题类图</p><hr><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h3 id="里氏替换原则的定义"><a href="#里氏替换原则的定义" class="headerlink" title="里氏替换原则的定义"></a>里氏替换原则的定义</h3><p>​        里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</p><h3 id="里氏替换原则的作用"><a href="#里氏替换原则的作用" class="headerlink" title="里氏替换原则的作用"></a>里氏替换原则的作用</h3><p>里氏替换原则的主要作用如下。</p><ol><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它克服了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li></ol><h3 id="里氏替换原则的实现方法"><a href="#里氏替换原则的实现方法" class="headerlink" title="里氏替换原则的实现方法"></a>里氏替换原则的实现方法</h3><p>​        里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>​        如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><p>下面以“几维鸟不是鸟”为例来说明里氏替换原则。</p><p>分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 1 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q11311094H32.gif" srcset="/img/loading.gif" alt="“几维鸟不是鸟”实例的类图"></p><p>​                                                                                “几维鸟不是鸟”实例的类图</p><pre><code class="java">public class LSPtest{    public static void main(String[] args)    {        Bird bird1=new Swallow();        Bird bird2=new BrownKiwi();        bird1.setSpeed(120);        bird2.setSpeed(120);        System.out.println(&quot;如果飞行300公里：&quot;);        try        {            System.out.println(&quot;燕子将飞行&quot;+bird1.getFlyTime(300)+&quot;小时.&quot;);            System.out.println(&quot;几维鸟将飞行&quot;+bird2.getFlyTime(300)+&quot;小时。&quot;);        }        catch(Exception err)        {            System.out.println(&quot;发生错误了!&quot;);        }    }}//鸟类class Bird{    double flySpeed;    public void setSpeed(double speed)    {        flySpeed=speed;    }    public double getFlyTime(double distance)    {        return(distance/flySpeed);    }}//燕子类class Swallow extends Bird{}//几维鸟类class BrownKiwi extends Bird{    public void setSpeed(double speed)    {           flySpeed=0;    }}/*如果飞行300公里：燕子将飞行2.5小时.几维鸟将飞行Infinity小时。*/</code></pre><hr><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><h3 id="依赖倒置原则的定义"><a href="#依赖倒置原则的定义" class="headerlink" title="依赖倒置原则的定义"></a>依赖倒置原则的定义</h3><p>​        依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁（Robert C.Martin）于 1996 年在  Report 上发表的文章。</p><p>​        <strong>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</strong>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。依赖倒置原则的主要作用如下。</p><h2 id="依赖倒置原则的实现方法"><a href="#依赖倒置原则的实现方法" class="headerlink" title="依赖倒置原则的实现方法"></a>依赖倒置原则的实现方法</h2><p>​        依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><p>【例1】依赖倒置原则在“顾客购物程序”中的应用。</p><pre><code class="java">class Customer{          public void shopping(ShaoguanShop shop)    {                 System.out.println(shop.sell());    //购物      }}</code></pre><p>但是，这种设计存在缺点，如果该顾客想从另外一家商店（如网店 WuyuanShop）购物，就要将该顾客的代码修改如下：</p><pre><code class="java">class Customer{            public void shopping(Shop shop)    {                    System.out.println(shop.sell());    //购物            }}</code></pre><p>这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图 1 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif" srcset="/img/loading.gif" alt="顾客购物程序的类图"></p><p>​                                                                        图1 顾客购物程序的类图</p><pre><code class="java">public class DIPtest{        public static void main(String[] args){             Customer wang=new Customer();          System.out.println(&quot;顾客购买以下商品：&quot;);         wang.shopping(new ShaoguanShop());         wang.shopping(new WuyuanShop());     }}//商店interface Shop{        public String sell(); //卖}//韶关网店class ShaoguanShop implements Shop{        public String sell(){            return &quot;韶关土特产：香菇、木耳……&quot;;    }}//婺源网店class WuyuanShop implements Shop{        public String sell(){            return &quot;婺源土特产：绿茶、酒糟鱼……&quot;;        }} //顾客class Customer{        public void shopping(Shop shop){            //购物                    System.out.println(shop.sell());    }}//运行结果：//顾客购买以下商品：//韶关土特产：香菇、木耳……//婺源土特产：绿茶、酒糟鱼……</code></pre><hr><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h3 id="单一职责原则的定义"><a href="#单一职责原则的定义" class="headerlink" title="单一职责原则的定义"></a>单一职责原则的定义</h3><p>​        单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。</p><ol><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li></ol><h3 id="单一职责原则的优点"><a href="#单一职责原则的优点" class="headerlink" title="单一职责原则的优点"></a>单一职责原则的优点</h3><p>​        单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。</p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li><li>提高类的可读性。复杂性降低，自然其可读性会提高。</li><li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><h3 id="单一职责原则的实现方法"><a href="#单一职责原则的实现方法" class="headerlink" title="单一职责原则的实现方法"></a>单一职责原则的实现方法</h3><p>​        单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。<br>【例1】大学学生工作管理程序。</p><p>​                                                    <img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q113133F4161.gif" srcset="/img/loading.gif" alt="大学学生工作管理程序的类图"><br>​                                                                                图1 大学学生工作管理程序的类图<br>注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于复用。</p><hr><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h3 id="接口隔离原则的定义"><a href="#接口隔离原则的定义" class="headerlink" title="接口隔离原则的定义"></a>接口隔离原则的定义</h3><p>​        接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><h3 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点"></a>接口隔离原则的优点</h3><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><h3 id="接口隔离原则的实现方法"><a href="#接口隔离原则的实现方法" class="headerlink" title="接口隔离原则的实现方法"></a>接口隔离原则的实现方法</h3><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>下面以学生成绩管理程序为例介绍接口隔离原则的应用。</p><p>​        分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中，其类图如图 1 所示。</p><p>​                                <img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q113141Q0X3.gif" srcset="/img/loading.gif" alt="学生成绩管理程序的类图"><br>​                                                                                图1 学生成绩管理程序的类图</p><pre><code class="java">public class ISPtest{    public static void main(String[] args)    {        InputModule input =StuScoreList.getInputModule();        CountModule count =StuScoreList.getCountModule();        PrintModule print =StuScoreList.getPrintModule();        input.insert();        count.countTotalScore();        print.printStuInfo();        //print.delete();    }}//输入模块接口interface InputModule{    void insert();    void delete();    void modify();}//统计模块接口interface CountModule{    void countTotalScore();    void countAverage();}//打印模块接口interface PrintModule{    void printStuInfo();    void queryStuInfo();}//实现类class StuScoreList implements InputModule,CountModule,PrintModule{    private StuScoreList(){}    public static InputModule getInputModule()    {        return (InputModule)new StuScoreList();    }    public static CountModule getCountModule()    {        return (CountModule)new StuScoreList();    }    public static PrintModule getPrintModule()    {        return (PrintModule)new StuScoreList();    }    public void insert()    {        System.out.println(&quot;输入模块的insert()方法被调用！&quot;);    }    public void delete()    {        System.out.println(&quot;输入模块的delete()方法被调用！&quot;);    }    public void modify()    {        System.out.println(&quot;输入模块的modify()方法被调用！&quot;);    }    public void countTotalScore()    {        System.out.println(&quot;统计模块的countTotalScore()方法被调用！&quot;);    }    public void countAverage()    {        System.out.println(&quot;统计模块的countAverage()方法被调用！&quot;);    }    public void printStuInfo()    {        System.out.println(&quot;打印模块的printStuInfo()方法被调用！&quot;);    }    public void queryStuInfo()    {        System.out.println(&quot;打印模块的queryStuInfo()方法被调用！&quot;);    }}/*运行结果：输入模块的insert()方法被调用！统计模块的countTotalScore()方法被调用！打印模块的printStuInfo()方法被调用！*/</code></pre><hr><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><h3 id="迪米特法则的定义"><a href="#迪米特法则的定义" class="headerlink" title="迪米特法则的定义"></a>迪米特法则的定义</h3><p>​        迪米特法则（Law of Demeter，LoD）又叫作，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。</p><p>​        迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p><h3 id="迪米特法则的实现方法"><a href="#迪米特法则的实现方法" class="headerlink" title="迪米特法则的实现方法"></a>迪米特法则的实现方法</h3><p>从迪米特法则的定义和特点可知，它强调以下两点：</p><ol><li>从依赖者的角度来说，只依赖应该依赖的对象。</li><li>从被依赖者的角度说，只暴露应该暴露的方法。</li></ol><p>所以，在运用迪米特法则时要注意以下 6 点。</p><p>分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如图 1 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q113152Q5W1.gif" srcset="/img/loading.gif" alt="明星与经纪人的关系图"></p><p>​                                                                    图1 明星与经纪人的关系图</p><pre><code class="java">public class LoDtest{    public static void main(String[] args)    {        Agent agent=new Agent();        agent.setStar(new Star(&quot;林心如&quot;));        agent.setFans(new Fans(&quot;粉丝韩丞&quot;));        agent.setCompany(new Company(&quot;中国传媒有限公司&quot;));        agent.meeting();        agent.business();    }}//经纪人class Agent{    private Star myStar;    private Fans myFans;    private Company myCompany;    public void setStar(Star myStar)    {        this.myStar=myStar;    }    public void setFans(Fans myFans)    {        this.myFans=myFans;    }    public void setCompany(Company myCompany)    {        this.myCompany=myCompany;    }    public void meeting()    {        System.out.println(myFans.getName()+&quot;与明星&quot;+myStar.getName()+&quot;见面了。&quot;);    }    public void business()    {        System.out.println(myCompany.getName()+&quot;与明星&quot;+myStar.getName()+&quot;洽淡业务。&quot;);    }}//明星class Star{    private String name;    Star(String name)    {        this.name=name;    }    public String getName()    {        return name;    }}//粉丝class Fans{    private String name;    Fans(String name)    {        this.name=name;    }    public String getName()    {        return name;    }}//媒体公司class Company{    private String name;    Company(String name)    {        this.name=name;    }    public String getName()    {        return name;    }}/*运行结果：粉丝韩丞与明星林心如见面了。中国传媒有限公司与明星林心如洽淡业务。*/</code></pre><hr><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><h2 id="合成复用原则的定义"><a href="#合成复用原则的定义" class="headerlink" title="合成复用原则的定义"></a>合成复用原则的定义</h2><p>合成复用原则（Composite Reuse Principle，CRP）又叫。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。<br>合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。通常类的复用分为和两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><h2 id="合成复用原则的实现方法"><a href="#合成复用原则的实现方法" class="headerlink" title="合成复用原则的实现方法"></a>合成复用原则的实现方法</h2><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。<br>下面以汽车分类管理程序为例来介绍合成复用原则的应用。                                                                                                   【例1】汽车分类管理程序。<br>    分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 1 所示是用继淨：关系实现的汽车分类的类图。</p><p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q113160133151.gif" srcset="/img/loading.gif" alt="用继承关系实现的汽车分类的类图"></p><p>​                                                                    图1 用继承关系实现的汽车分类的类图</p><p>​        从图 1 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。</p><p>​                        <img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q11316034X57.gif" srcset="/img/loading.gif" alt="用组合关系实现的汽车分类的类图"><br>​                                                                图2 用组合关系实现的汽车分类的类图</p><pre><code>  结合前几节的内容，我们一共介绍了 7 种设计原则，它们分别为开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、迪米特法则和本节所介绍的合成复用原则。</code></pre><p>​        这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，</p><ol><li>开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；</li><li>里氏替换原则告诉我们不要破坏继承体系；</li><li>依赖倒置原则告诉我们要面向接口编程；</li><li>单一职责原则告诉我们实现类要职责单一；</li><li>接口隔离原则告诉我们在设计接口的时候要精简单一；</li><li>迪米特法则告诉我们要降低耦合度；</li><li>合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。  </li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>设计模式是五大或六大还是七大原则?</p><p>设计模式有五大原则或七大原则之分<br>按五大原则划分：1、2、3和4（算一种）、5和6（算一种）、7<br>按六大原则划分：1、2、3、4、5和6（算一种）、7<br>按七大原则划分：1、2、3、4、5、6、7</p><p>1.单一职责原则(Single Responsibility Principle,SRP)：类的职责要单一，不能将太多的职责放在一个类中。（高内聚、低耦合）</p><p>2.开闭原则( Open - ClosedPrinciple ,OCP )：对扩展开放，对修改关闭（设计模式的核心原则是）</p><p>3.依赖倒转原则( Dependence Inversion Principle ,DIP )：要依赖抽象,而不要依赖具体的实现.</p><p>4.里氏代换原则( Liskov Substitution Principle ,LSP )：任何基类可以出现的地方,子类也可以出现</p><p>5.迪米特法则(Law of Demeter，LoD：系统中的类,尽量不要与其他类互相作用,减少类之间的耦合度<br>定义：又叫最少知识原则（Least Knowledge Principle或简写为LKP）几种形式定义：<br>(1) 不要和“陌生人”说话。英文定义为：Don’t talk to strangers.<br>(2) 只与你的直接朋友通信。英文定义为：Talk only to your immediatefriends.</p><p>6.接口隔离法则(Interface Segregation Principle，ISL）：客户端不应该依赖那些它不需要的接口。（这个法则与迪米特法则是相通的）</p><p>7 .合成/聚合复用原则(Composite/Aggregate ReusePrinciple ，CARP)：要尽量使用对象组合,而不是继承关系达到软件复用的目的</p><p>其中合成/聚合复用原则又可以细分为二种<br>聚合(Aggregation) 关系是关联关系的一种，是弱的关联关系。比如乐队（主唱，吉他手，贝斯手）<br>组合(Composition) 关系是关联关系的一种，是强的关联关系。比如每名乐手（灵魂、身体）</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内功</tag>
      
      <tag>概念文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式概念</title>
    <link href="/2018/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2018/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="软件设计模式意义"><a href="#软件设计模式意义" class="headerlink" title="软件设计模式意义"></a>软件设计模式意义</h2><p>​        设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。<br>​        可以提高程序员的思维能力、编程能力和设计能力。使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。</p><h2 id="软件设计模式概念"><a href="#软件设计模式概念" class="headerlink" title="软件设计模式概念"></a>软件设计模式概念</h2><p>​        软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p><h2 id="设计模式基本要素"><a href="#设计模式基本要素" class="headerlink" title="设计模式基本要素"></a>设计模式基本要素</h2><p>​        软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。</p><h3 id="1-模式名称"><a href="#1-模式名称" class="headerlink" title="1. 模式名称"></a>1. 模式名称</h3><p>​        每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。</p><h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h3><p>​        问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。</p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><p>​        模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。</p><h3 id="4-效果"><a href="#4-效果" class="headerlink" title="4. 效果"></a>4. 效果</h3><p>​        描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。</p><hr><h1 id="GOF的23种设计模式"><a href="#GOF的23种设计模式" class="headerlink" title="GOF的23种设计模式"></a>GOF的23种设计模式</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="1-根据目的来分"><a href="#1-根据目的来分" class="headerlink" title="1. 根据目的来分"></a>1. 根据目的来分</h3><p>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式结构型模行为型模式</p><ol><li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li><li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li><li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li></ol><h3 id="2-根据作用范围来分"><a href="#2-根据作用范围来分" class="headerlink" title="2. 根据作用范围来分"></a>2. 根据作用范围来分</h3><p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式对象模式</p><ol><li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</li><li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。</li></ol><table><thead><tr><th align="center">范围\目的</th><th align="center">创建型模式</th><th align="center">结构型模式</th><th align="center">行为型模式</th></tr></thead><tbody><tr><td align="center">类模式</td><td align="center">工厂方法</td><td align="center">(类）适配器</td><td align="center">模板方法、解释器</td></tr><tr><td align="center">对象模式</td><td align="center">单例 原型 抽象工厂 建造者</td><td align="center">代理 (对象）适配器 桥接 装饰 外观 享元 组合</td><td align="center">策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录</td></tr></tbody></table><h3 id="3-GoF的23种设计模式的功能"><a href="#3-GoF的23种设计模式的功能" class="headerlink" title="3. GoF的23种设计模式的功能"></a>3. GoF的23种设计模式的功能</h3><p>前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。</p><ol><li><p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p></li><li><p>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p></li><li><p>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</p></li><li><p>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p></li><li><p>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p></li><li><p>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p></li><li><p>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p></li><li><p>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p></li><li><p>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</p></li><li><p>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p></li><li><p>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</p></li><li><p>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p></li><li><p>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p></li><li><p>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p></li><li><p>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p></li><li><p>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</p></li><li><p>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</p></li><li><p>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</p></li><li><p>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</p></li><li><p>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p></li><li><p>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</p></li><li><p>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p></li><li><p>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p><hr></li></ol><p>必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式，希望读者认真学好它们。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内功</tag>
      
      <tag>概念文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/1949/10/01/Hello-Hexo/"/>
    <url>/1949/10/01/Hello-Hexo/</url>
    
    <content type="html"><![CDATA[<p>手动摘要：第一使用Hexo博客框架记录一下相关使用的笔记</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><h3 id="新建Hexo项目"><a href="#新建Hexo项目" class="headerlink" title="新建Hexo项目"></a>新建Hexo项目</h3><pre><code class="bash">$ hexo init 项目名</code></pre><p>前提是安装好了Hexo</p><h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;$ hexo n [模板] 文章名字</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code class="bash">$ hexo server$ hexo s --debug  这样就可以在本地边写边预览啦</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><pre><code class="bash">$ hexo generate$ hexo g</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="发布到站点"><a href="#发布到站点" class="headerlink" title="发布到站点"></a>发布到站点</h3><pre><code class="bash">$ hexo deploy$ hexo d</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><h2 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h2><p>主要是修改Hexo根目录下的 _config.yml 文件</p><p><a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">详情参考</a></p><h2 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h2><pre><code class="markdown">在本件头部编辑---title: 文章标题tags: [多个标签用逗号分隔]tags: 单个标签index_img: 目录预览文章图片 /img/example.jpgbanner_img: 文章头部图片 /img/post_banner.jpgcategories: 文章分类date: 可以自定义发表时间---</code></pre>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小记</tag>
      
      <tag>Hexo使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
